<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>FootyJoy — EPL 情報ビュー（日本語）</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body class="bg-slate-50 text-slate-900">
    <div id="root"></div>

    <script type="text/babel">
      const {useState,useEffect,useMemo} = React;
      const cn=(...c)=>c.filter(Boolean).join(" ");
      const uid=()=>Math.random().toString(36).slice(2)+Date.now().toString(36);

      // ===== 抽出ロジック =====
      function splitSentences(text){ if(!text) return []; return String(text).replace(/\s+/g," ").split(/(?<=[\.!?。！？])\s+/).map(s=>s.trim()).filter(Boolean); }
      function normalizeStr(s){ return (s||"").toLowerCase().normalize("NFKD").replace(/[\u0300-\u036f]/g,"").replace(/[^a-z0-9\u3040-\u30ff\u4e00-\u9faf\s-]/g,""); }
      function buildPlayerIndex(players){ const idx=new Map(); for(const p of players||[]){ const names=[p.name_en,p.name_local,...(p.alt||[])].filter(Boolean); for(const n of names){ idx.set(normalizeStr(n), p); } } return idx; }
      function matchHighlights(text, players, keywords){
        const sentences=splitSentences(text).slice(0,400);
        const idx=buildPlayerIndex(players);
        const K={
          injury:    new Set((keywords?.injury    || []).map(normalizeStr)),
          returning: new Set((keywords?.returning || []).map(normalizeStr)),
          form:      new Set((keywords?.form      || []).map(normalizeStr)),
        };
        const out=[];
        for(const raw of sentences){
          const s=normalizeStr(raw);
          const inj=[...K.injury].some(k=>s.includes(k));
          const ret=[...K.returning].some(k=>s.includes(k));
          const frm=[...K.form].some(k=>s.includes(k));
          if(!inj && !ret && !frm) continue;
          for(const [key,p] of idx.entries()){
            if(key && s.includes(key)){
              out.push({ player:p.name_en||key, kind: inj? "injury" : ret? "returning" : "form", sentence: raw.trim() });
            }
          }
        }
        const ded=[]; for(const h of out){ if(!ded.some(x=>x.player===h.player&&x.kind===h.kind&&x.sentence===h.sentence)) ded.push(h); }
        return ded.slice(0,50);
      }

      // ===== 日本語表示ヘルパ =====
      function jaKind(k){ return k==="injury"?"負傷":k==="returning"?"復帰":"好調"; }
      function chipClass(k){
        return k==="injury"    ? "bg-red-50 border-red-400 text-red-700" :
               k==="returning" ? "bg-amber-50 border-amber-400 text-amber-700" :
                                 "bg-green-50 border-green-400 text-green-700";
      }
      function fmtJP(ts){ try{ return new Date(ts).toLocaleString("ja-JP",{hour12:false}); }catch{ return ""; } }

      // ===== 翻訳（常時ON・ローカルキャッシュ）=====
      const tKey = (s)=> btoa(unescape(encodeURIComponent(String(s)))).slice(0,120);
      function useTranslator(){
        const [cache,setCache]=useState(()=>{ try{ return JSON.parse(localStorage.getItem("fj.tcache")||"{}"); }catch{return{}}; });
        useEffect(()=> localStorage.setItem("fj.tcache", JSON.stringify(cache)), [cache]);
        async function trOnce(s){
          const k=tKey(s); if(cache[k]) return cache[k];
          const r=await fetch("/api/translate?q="+encodeURIComponent(s));
          const data=await r.json(); const text=data?.text||"";
          setCache(c=>({...c,[k]:text})); return text;
        }
        const get=(s)=>cache[tKey(s)];
        return {trOnce, get};
      }

      // ===== チーム名（プルダウン表示）=====
      const TEAM_LABELS = {
        ARS:"Arsenal", MCI:"Man City", LIV:"Liverpool", TOT:"Tottenham",
        MUN:"Man United", CHE:"Chelsea", NEW:"Newcastle", BHA:"Brighton",
        AVL:"Aston Villa", WHU:"West Ham", BRE:"Brentford", EVE:"Everton",
        LEI:"Leicester", WOL:"Wolves", SOU:"Southampton", CRY:"Crystal Palace",
        FUL:"Fulham", NOT:"Nottingham", BOU:"Bournemouth", IPS:"Ipswich"
      };

      // ===== 簡易ソース信頼度（色分け）=====
      function sourceBadge(u){
        try{
          const host=new URL(u).host;
          if(/arsenal\.com|mancity\.com|liverpoolfc\.com|tottenhamhotspur\.com|manutd\.com|chelseafc\.com/.test(host)) return ["公式","bg-indigo-50 text-indigo-700 border-indigo-400"];
          if(/bbc\.com/.test(host)) return ["BBC","bg-sky-50 text-sky-700 border-sky-400"];
          if(/skysports\.com/.test(host)) return ["Sky","bg-cyan-50 text-cyan-700 border-cyan-400"];
          return ["報道","bg-slate-50 text-slate-700 border-slate-300"];
        }catch{ return ["", "bg-slate-50 text-slate-700 border-slate-300"]; }
      }

      function App(){
        const [tab,setTab]=useState("intel");

        // データ
        const [players,setPlayers]=useState([]);
        const [keywords,setKeywords]=useState({injury:[],returning:[],form:[]});
        const [roster,setRoster]=useState([]);   // ウォッチ選手（英語表記）
        const [sources,setSources]=useState([]);

        const {trOnce, get:tget}=useTranslator();

        // 起動時に辞書ロード
        useEffect(()=>{ (async ()=>{
          const [kw,pl]=await Promise.all([
            fetch("/config/keywords.json").then(r=>r.json()),
            fetch("/config/players.json").then(r=>r.json()),
          ]);
          setKeywords(kw); setPlayers(pl);
        })(); },[]);

        // ウォッチ管理
        function addWatch(name){ const n=String(name||"").trim(); if(n && !roster.includes(n)) setRoster(r=>[...r,n]); }
        function removeWatch(n){ setRoster(r=>r.filter(x=>x!==n)); }

        // 取得
        async function addSource(url){
          const u = normalizeUrl(url);
          try{
            const r=await fetch(`/api/grab?url=${encodeURIComponent(u)}`);
            if(!r.ok) throw new Error("取得に失敗しました");
            const data=await r.json();
            const text = data.text || `${data.title||""} ${data.desc||""}`;
            const highlights = matchHighlights(text, players, keywords);
            setSources(s=>[{ id:uid(), url:u, title:data.title||u, desc:data.desc||"", fetchedAt:Date.now(), highlights }, ...s]);
          }catch(e){ alert("取得失敗: "+e.message); }
        }
        async function quickScan(){
          try{
            const r=await fetch("/api/scan-epl?limit=32");
            if(!r.ok) throw new Error("スキャンに失敗しました");
            const data=await r.json();
            setSources(s=>{
              const seen=new Set(s.map(x=>x.url));
              const add=(data.sources||[]).filter(x=>!seen.has(x.url));
              return [...add, ...s];
            });
          }catch(e){ alert(e.message); }
        }

        // インサイト：ウォッチ＆タグ絞り込み
        const [filterKinds,setFilterKinds]=useState({injury:true, returning:true, form:true});
        const insightsRaw = useMemo(()=>{
          const arr=[];
          for(const s of sources){
            for(const h of (s.highlights||[])){
              if(!roster.length || roster.some(n=>eqName(n,h.player))){
                arr.push({...h, url:s.url, title:s.title, ts:s.fetchedAt});
              }
            }
          }
          return arr.sort((a,b)=>b.ts-a.ts);
        },[sources,roster]);
        const insights = useMemo(()=> insightsRaw.filter(i=>filterKinds[i.kind]), [insightsRaw, filterKinds]);

        // 翻訳先読み
        useEffect(()=>{
          const uniq = Array.from(new Set(insights.map(i=>i.sentence))).slice(0,20);
          uniq.forEach(s=>{ if(!tget(s)) trOnce(s); });
        },[insights]);

        const watchPlayers=useMemo(()=> roster.map(n=>({name:n, facts: insightsRaw.filter(i=>eqName(i.player,n)).slice(0,3)})), [roster,insightsRaw]);

        // ===== 試合プリセット + 定番ソース =====
        const [homeTeam,setHomeTeam]=useState("");
        const [awayTeam,setAwayTeam]=useState("");
        const [teamSources,setTeamSources]=useState(null);
        useEffect(()=>{ fetch("/config/team_sources.json").then(r=>r.json()).then(setTeamSources).catch(()=>setTeamSources({})); },[]);
        const teamOptions = useMemo(()=> Array.from(new Set(players.map(p=>p.teamId))).sort(), [players]);
        const teamName = (id)=> TEAM_LABELS[id] || id;

        function startMatchPreset(){
          const ids=[homeTeam,awayTeam].filter(Boolean);
          if(!ids.length) return alert("チームを選んでください");
          const names = players.filter(p=>ids.includes(p.teamId)).map(p=>p.name_en);
          setRoster(Array.from(new Set(names)));
          quickScan();
        }
        async function fetchTeamDefaultSources(){
          const ids=[homeTeam,awayTeam].filter(Boolean);
          if(!ids.length) return alert("チームを選んでください");
          const urls = [];
          for(const id of ids){
            (teamSources?.[id]||[]).forEach(s=> urls.push(s.url));
          }
          const uniq=[...new Set(urls)];
          for(const u of uniq){ await addSource(u); await new Promise(r=>setTimeout(r,150)); }
        }
        function clearMatchPreset(){ setHomeTeam(""); setAwayTeam(""); setRoster([]); }

        // ===== エクスポート（Markdown）=====
        function exportMarkdown(){
          const lines=[];
          lines.push(`# 試合メモ`);
          if(homeTeam||awayTeam) lines.push(`- 対象: ${homeTeam?teamName(homeTeam):""}${awayTeam?` vs ${teamName(awayTeam)}`:""}`);
          lines.push("");
          const byPlayer=new Map();
          for(const i of insights){
            const arr=byPlayer.get(i.player)||[]; arr.push(i); byPlayer.set(i.player,arr);
          }
          for(const [name,arr] of byPlayer){
            lines.push(`## ${name}`);
            for(const i of arr){
              lines.push(`- **${jaKind(i.kind)}**: ${i.sentence} ([出典](${i.url}))`);
            }
            lines.push("");
          }
          const blob=new Blob([lines.join("\n")],{type:"text/markdown"});
          const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download="footyjoy_insights.md"; a.click();
          setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
        }

        // ===== UI =====
        return (
          <div className="min-h-screen">
            <header className="sticky top-0 z-20 border-b bg-white/90 backdrop-blur">
              <div className="mx-auto max-w-7xl px-4 py-3 flex items-center gap-3">
                <div className="text-xl font-bold">⚽ FootyJoy <span className="text-slate-500 text-sm">EPL 情報ビュー</span></div>
                <nav className="ml-2 rounded-full bg-slate-100 p-1 text-sm">
                  <button onClick={()=>setTab("intel")} className={cn("px-3 py-1 rounded-full", tab==="intel"?"bg-white shadow":"hover:bg-white/60")}>情報</button>
                  <button onClick={()=>setTab("matches")} className={cn("px-3 py-1 rounded-full", tab==="matches"?"bg-white shadow":"hover:bg-white/60")}>観戦メモ</button>
                </nav>
                {tab==="intel" && (
                  <div className="ml-3 flex items-center gap-2 text-sm">
                    <button onClick={quickScan} className="rounded-xl border px-3 py-1.5 hover:bg-slate-100">クイックスキャン（EPL）</button>
                    <button onClick={exportMarkdown} className="rounded-xl border px-3 py-1.5 hover:bg-slate-100">Markdown出力</button>
                    <span className="text-slate-500">選手数: {players.length||0}</span>
                  </div>
                )}
                {tab==="matches" && (
                  <button onClick={()=>setMatches(m=>[{id:uid(), when:new Date().toISOString(), memo:""}, ...m])}
                          className="ml-3 rounded-xl border px-3 py-1.5 text-sm hover:bg-slate-100">＋追加</button>
                )}
              </div>
            </header>

            {tab==="intel" ? (
              <main className="mx-auto max-w-7xl px-4 py-6 grid grid-cols-1 lg:grid-cols-3 gap-6">
                {/* 試合プリセット */}
                <section className="lg:col-span-3">
                  <div className="rounded-3xl bg-white p-4 shadow-sm">
                    <h2 className="text-lg font-semibold">試合プリセット</h2>
                    <div className="mt-3 grid grid-cols-1 sm:grid-cols-3 gap-2">
                      <select className="rounded-xl border px-3 py-1.5" value={homeTeam} onChange={e=>setHomeTeam(e.target.value)}>
                        <option value="">ホームを選択</option>
                        {Array.from(new Set(players.map(p=>p.teamId))).sort().map(id => <option key={id} value={id}>{TEAM_LABELS[id]||id}</option>)}
                      </select>
                      <select className="rounded-xl border px-3 py-1.5" value={awayTeam} onChange={e=>setAwayTeam(e.target.value)}>
                        <option value="">アウェイを選択</option>
                        {Array.from(new Set(players.map(p=>p.teamId))).sort().map(id => <option key={id} value={id}>{TEAM_LABELS[id]||id}</option>)}
                      </select>
                      <div className="flex gap-2">
                        <button onClick={startMatchPreset} className="flex-1 rounded-xl border px-3 py-1.5 hover:bg-slate-100">この試合を開始</button>
                        <button onClick={clearMatchPreset} className="rounded-xl border px-3 py-1.5 hover:bg-slate-100">解除</button>
                      </div>
                    </div>
                    <div className="mt-3 flex flex-wrap gap-2">
                      <button onClick={fetchTeamDefaultSources} className="rounded-xl border px-3 py-1.5 text-sm hover:bg-slate-100">